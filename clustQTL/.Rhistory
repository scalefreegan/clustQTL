mrk
qtls
markers_yeast_chr01
plotManhattan(clust_qtl,markers_yeast, gene,trx_annot=tx_3utr_annotations_yeast_chr01)
library(clustQTL)
plotManhattan(clust_qtl,markers_yeast, gene,trx_annot=tx_3utr_annotations_yeast_chr01)
mrk = markers_yeast
mrk2 = format4manhattan( qtls,mrk )
mrk2
plotGrandLinear(mrk2, aes(y = p),spaceline = TRUE,cutoff=cutoff,ylab="-log10(pval)",main=qtl_name,ylim=c(0,4.5))
cutoff=3
plotGrandLinear(mrk2, aes(y = p),spaceline = TRUE,cutoff=cutoff,ylab="-log10(pval)",main=qtl_name,ylim=c(0,4.5))
qtl_name = "gene"
plotGrandLinear(mrk2, aes(y = p),spaceline = TRUE,cutoff=cutoff,ylab="-log10(pval)",main=qtl_name,ylim=c(0,4.5))
mrk2
mrk2$p
min(mrk2$p)
max(mrk2$p)
plotManhattan(clust_qtl,markers_yeast, gene,trx_annot=tx_3utr_annotations_yeast_chr01)
tx_3utr_annotations_yeast_chr01
plotManhattan(clust_qtl,markers_yeast, gene)
trx_annot=tx_3utr_annotations_yeast_chr01
qtl_name
qtl_name = i
qtl_name
trx_annot[ which(trx_annot$Name == qtl_name), ]
trx_info = trx_annot[ which(trx_annot$Name == qtl_name), ]
trx_granges = GRanges(seqnames=trx_info$seqnames,
ranges=IRanges(trx_info$start-gene_annot_range[1],
trx_info$end+gene_annot_range[2]))
trx_info
ranges(trx_info)
ranges(trx_info)$start
ranges(trx_info)[[1]]
ranges(trx_info)[1]
ranges(trx_info)$start
ranges(trx_info,start)
ranges(trx_info)
start(ranges(trx_info))
end(ranges(trx_info))
trx_granges = GRanges(seqnames=trx_info$seqnames,
ranges=IRanges(start(ranges(trx_info))-gene_annot_range[1],
end(ranges(trx_info))+gene_annot_range[2]))
gene_annot_range = c(5000,5000)
trx_granges = GRanges(seqnames=seqnames(trx_info),
ranges=IRanges(start(ranges(trx_info))-gene_annot_range[1],
end(ranges(trx_info))+gene_annot_range[2]))
trx_granges
plotManhattan(clust_qtl,markers_yeast, gene,trx_annot=tx_3utr_annotations_yeast_chr01)
trx_info = trx_annot[ which(trx_annot$Name == qtl_name), ]
trx_granges = GRanges(seqnames=seqnames(trx_info),
ranges=IRanges(start(ranges(trx_info))-gene_annot_range[1],
end(ranges(trx_info))+gene_annot_range[2]))
names(trx_granges) = qtl_name
library(clustQTL)
library(clustQTL)
clust_qtl = clustANDscore(data,genotypes_yeast,distance="cosine")
clust_qtl
clust_qtl[,2]
min(clust_qtl[,2])
peaks = findQTLPeaks(clust_qtl,markers_yeast)
peaks
peaks = findQTLPeaks(clust_qtl,markers_yeast)
peak_genotypes = do.call(rbind,lapply(names(peaks),function(i){getGenotypes(i,genotypes_yeast)}))
rownames(peak_genotypes) = names(peaks)
peak_genotypes
gene = "YAL041W"
data = t(as.matrix(mcols(subsetByOverlaps(tx3_counts_chr01,tx_3utr_annotations_yeast_chr01[gene]))))
# need to clean up data names
rnames = sapply( sub("X","",sapply( rownames(data), function(i) strsplit(i,"_")[[1]][1] ) ), function(i) {
if (nchar(i)==2){
i = paste("0",i,sep="")
}
i
} )
rownames(data) = rnames
# remove insig peaks
peak_cutoff = find_sigCounts( data )
data_o = data
data[ , colSums(data)<peak_cutoff ] = 0
data = data[rownames(data)%in%colnames(genotypes_yeast),]
clust_qtl = clustANDscore(data,genotypes_yeast,distance="cosine")
peaks = findQTLPeaks(clust_qtl,markers_yeast)
peak_genotypes = do.call(rbind,lapply(names(peaks),function(i){getGenotypes(i,genotypes_yeast)}))
rownames(peak_genotypes) = names(peaks)
peaks
x = 1
A = names(which(peak_genotypes[x,] == 1))
A = intersect( A, rownames(data) )
B = names(which(peak_genotypes[x,] == 2))
B = intersect( B, rownames(data) )
pheatmap(data[c(A,B),],cluster_cols=F,cluster_rows=T,scale="row",annotation_row=data.frame(rbind(cbind(A,"S"),cbind(B,"Y")),row.names=1))
library(pheatmap)
pheatmap(data[c(A,B),],cluster_cols=F,cluster_rows=T,scale="row",annotation_row=data.frame(rbind(cbind(A,"S"),cbind(B,"Y")),row.names=1))
pheatmap(data[c(A,B),],cluster_cols=F,cluster_rows=T,scale="none",annotation_row=data.frame(rbind(cbind(A,"S"),cbind(B,"Y")),row.names=1))
pheatmap(data[c(A,B),],cluster_cols=F,cluster_rows=F,scale="none",annotation_row=data.frame(rbind(cbind(A,"S"),cbind(B,"Y")),row.names=1))
data = data[which(apply(data,1,sum)>0,useNames=T),]
pheatmap(data[c(A,B),],cluster_cols=F,cluster_rows=F,scale="rows",annotation_row=data.frame(rbind(cbind(A,"S"),cbind(B,"Y")),row.names=1))
pheatmap(data[c(A,B),],cluster_cols=F,cluster_rows=F,scale="row",annotation_row=data.frame(rbind(cbind(A,"S"),cbind(B,"Y")),row.names=1))
pheatmap(data[c(A,B),],cluster_cols=F,cluster_rows=T,scale="row",annotation_row=data.frame(rbind(cbind(A,"S"),cbind(B,"Y")),row.names=1))
all_cor = cor(t(data[c(A,B),]),use="pair",method="pearson")
in_a = all_cor[A,A]
in_b = all_cor[B,B]
out_ab = all_cor[A,B]
out_ba = all_cor[B,A]
mean(in_a[upper.tri(in_a)],na.rm=T)
mean(in_b[upper.tri(in_b)],na.rm=T)
mean(out_ab[upper.tri(out_ab)],na.rm=T)
mean(out_ba[upper.tri(out_ba)],na.rm=T)
peaks
clust_qtl
clust_qtl[,1]
chist(lust_qtl[,1])
hist(clust_qtl[,1])
min(clust_qtl[,1])
sort(clust_qtl[,1])
sort(clust_qtl[,1],decreasing=T)
sort(clust_qtl[,1],decreasing = T)
sort(clust_qtl[,1],decreasing = F
)
sort(clust_qtl[,1],decreasing = T)
tail(sort(clust_qtl[,1],decreasing = T))
pheatmap(data[c(A,B),],cluster_cols=F,cluster_rows=T,scale="row",annotation_row=data.frame(rbind(cbind(A,"S"),cbind(B,"Y")),row.names=1))
pheatmap(data[c(A,B),],cluster_cols=F,cluster_rows=T,scale="row",annotation_row=data.frame(rbind(cbind(A,"S"),cbind(B,"Y")),row.names=1))
pheatmap(clustering_distance_rows = )
pheatmap(data[c(A,B),],cluster_cols=F,cluster_rows=T,scale="row",annotation_row=data.frame(rbind(cbind(A,"S"),cbind(B,"Y")),row.names=1),clustering_distance_rows =cosineDist((data[c(A,B),]))
)
pheatmap(pheatmap(cosineDist(data[c(A,B),]),cluster_cols=F,cluster_rows=T,scale="row",annotation_row=data.frame(rbind(cbind(A,"S"),cbind(B,"Y")),row.names=1)))
pheatmap(cosineDist(data[c(A,B),]),cluster_cols=F,cluster_rows=T,scale="row",annotation_row=data.frame(rbind(cbind(A,"S"),cbind(B,"Y")),row.names=1))
pheatmap(t(cosineDist(data[c(A,B),]))\,cluster_cols=F,cluster_rows=T,scale="row",annotation_row=data.frame(rbind(cbind(A,"S"),cbind(B,"Y")),row.names=1))
pheatmap(t(cosineDist(data[c(A,B),]))\,cluster_cols=F,cluster_rows=T,scale="row",annotation_row=data.frame(rbind(cbind(A,"S"),cbind(B,"Y")),row.names=1))
pheatmap(t(cosineDist(data[c(A,B),])),cluster_cols=F,cluster_rows=T,scale="row",annotation_row=data.frame(rbind(cbind(A,"S"),cbind(B,"Y")),row.names=1))
pheatmap(t(cosineDist(data[c(A,B),])),cluster_cols=F,cluster_rows=F,scale="row",annotation_row=data.frame(rbind(cbind(A,"S"),cbind(B,"Y")),row.names=1))
line(y~x)
abline(y~x)
abline(1,0)
plot(c(1,2,3))
abline(1,0)
abline(0,1)
dim(geno)
library(clustQTL)
gene = "YAL041W"
#gene = sample(names(tx_3utr_annotations_yeast_chr01),1)
x = subsetByOverlaps(tx3_counts_chr01,tx_3utr_annotations_yeast_chr01[gene])
data = t(granges2matrix(x))
# log transform
data[data==0] = NA
data = log2(data)
data[is.na(data)] = 0
# need to clean up data names
rnames = sapply( sub("X","",sapply( rownames(data), function(i) strsplit(i,"_")[[1]][1] ) ), function(i) {
if (nchar(i)==2){
i = paste("0",i,sep="")
}
i
} )
rownames(data) = rnames
# remove insig peaks
peak_cutoff = find_sigCounts( data )
data_o = data
data[ , colSums(data)<peak_cutoff ] = 0
library(clustQTL)
library(GenomicRanges)
library(ggbio)
library(pheatmap)
gene = "YAL041W"
#gene = sample(names(tx_3utr_annotations_yeast_chr01),1)
x = subsetByOverlaps(tx3_counts_chr01,tx_3utr_annotations_yeast_chr01[gene])
data = t(granges2matrix(x))
# log transform
data[data==0] = NA
data = log2(data)
data[is.na(data)] = 0
# need to clean up data names
rnames = sapply( sub("X","",sapply( rownames(data), function(i) strsplit(i,"_")[[1]][1] ) ), function(i) {
if (nchar(i)==2){
i = paste("0",i,sep="")
}
i
} )
rownames(data) = rnames
# remove insig peaks
peak_cutoff = find_sigCounts( data )
data_o = data
data[ , colSums(data)<peak_cutoff ] = 0
data = data[rownames(data)%in%colnames(genotypes_yeast),]
clust_qtl = clustANDscore(data,genotypes_yeast,distance="cosine")
clust_qtl
min(clust_qtl)
p.adjust(min(clust_qtl),method = "BH")
p.adjust(clust_qtl,method = "BH")
min(p.adjust(clust_qtl,method = "BH"))
min(p.adjust(clust_qtl,method = "BH"))
library(clustQTL)
clust_qtl = clustANDscore(data,genotypes_yeast,distance="cosine")
clust_qtl
min(clust_qtl)
library(clustQTL)
clust_qtl = clustANDscore(data,genotypes_yeast,distance="cosine")
library(clustQTL)
clust_qtl = clustANDscore(data,genotypes_yeast,distance="cosine")
genotypes = genotypes_yeast
data = data[which(apply(data,1,sum)>0,useNames=T),]
# only use data for clustering
data = data[intersect(colnames(genotypes),rownames(data)),]
clustering = cluster(data)
genotype_template = rownames(data)
names(genotype_template) = genotype_template
x = 1
genotype_vector=sapply(genotype_template,function(i){
if (class(try(genotypes[x,i],silent=T))!="try-error"){
return(genotypes[x,i])
} else {
return(NA)
}
})
genotype_vector = genotype_vector[!is.na(genotype_vector)]
one_score = score(clustering$clustering,genotype_vector)
genotype_vector
one_score
clustering$clustering
one_score = score(clustering$clustering,genotype_vector)
clusters = clustering$clustering
clusters
clusters = clusters[intersect(names(genotype_vector),names(clusters))]
genotype_vector = genotype_vector[names(clusters)]
# find best match to assign genotypes
genotype_vector = as.numeric(as.factor(genotype_vector))
genotype_vector
if ( cor(genotype_vector,clusters) < 0 ) {
# switch labels
new_genotype_vector = genotype_vector
new_genotype_vector[genotype_vector==1] = 2
new_genotype_vector[genotype_vector==2] = 1
genotype_vector = new_genotype_vector
}
# compute pval by exact binomial test
# calc hypothesized prob success given
# genotype vector and cluster composition
# p(1,1) + p(2,2)
p_hyp = sum(clusters==1)/length(clusters)*sum(genotype_vector==1)/length(genotype_vector) +
sum(clusters==2)/length(clusters)*sum(genotype_vector==2)/length(genotype_vector)
score = binom.test(sum(clusters==genotype_vector),length(clusters),p_hyp,"greater")
score
score = function(clusters, genotype_vector,verbose=FALSE) {
# order clusters and genotypes_vector
clusters = clusters[intersect(names(genotype_vector),names(clusters))]
genotype_vector = genotype_vector[names(clusters)]
# find best match to assign genotypes
genotype_vector = as.numeric(as.factor(genotype_vector))
if ( cor(genotype_vector,clusters) < 0 ) {
# switch labels
new_genotype_vector = genotype_vector
new_genotype_vector[genotype_vector==1] = 2
new_genotype_vector[genotype_vector==2] = 1
genotype_vector = new_genotype_vector
}
# compute pval by exact binomial test
# calc hypothesized prob success given
# genotype vector and cluster composition
# p(1,1) + p(2,2)
p_hyp = sum(clusters==1)/length(clusters)*sum(genotype_vector==1)/length(genotype_vector) +
sum(clusters==2)/length(clusters)*sum(genotype_vector==2)/length(genotype_vector)
score = binom.test(sum(clusters==genotype_vector),length(clusters),p_hyp,"greater")
return(score)
}
one_score = score(clustering$clustering,genotype_vector)
clustering$clustering
genotype_vector
x = 1
genotype_vector=sapply(genotype_template,function(i){
if (class(try(genotypes[x,i],silent=T))!="try-error"){
return(genotypes[x,i])
} else {
return(NA)
}
})
genotype_vector = genotype_vector[!is.na(genotype_vector)]
one_score = score(clustering$clustering,genotype_vector)
one_score
matrix(c(one_score$statistic[[1]],one_score$p.value), nrow = 1, ncol = 2, dimnames = list("matches","pval"))
cbind(one_score$statistic[[1]],one_score$p.value)
cbind(one_score$statistic[[1]],one_score$p.value)
matrix(cbind(one_score$statistic[[1]],one_score$p.value), nrow = 1, ncol = 2, dimnames = list("matches","pval"))
o = cbind(one_score$statistic[[1]],one_score$p.value)
colnames(o) = c("matches","pval")
o
to_r = do.call(rbind,mclapply(seq(1:dim(genotypes)[1]),function(x){
genotype_vector=sapply(genotype_template,function(i){
if (class(try(genotypes[x,i],silent=T))!="try-error"){
return(genotypes[x,i])
} else {
return(NA)
}
})
genotype_vector = genotype_vector[!is.na(genotype_vector)]
one_score = score(clustering$clustering,genotype_vector)
o = cbind(one_score$statistic[[1]],one_score$p.value)
colnames(o) = c("matches","pval")
return(o)
}))
head(to_r)
to_r[,"pval"] = p.adjust(to_r[,"pval"],method = "BH")
head(to_r)
clustANDscore = function(data, genotypes,...) {
# change data names to match genotypes
# new_names = sapply(rownames(data),namematch,colnames(genotypes))
# remove names that don't match from data
# data = data[!is.na(new_names),]
# rownames(data) = new_names[!is.na(new_names)]
# only keep data with at least one positive value
# otherwise will bias clustering
data = data[which(apply(data,1,sum)>0,useNames=T),]
# only use data for clustering
data = data[intersect(colnames(genotypes),rownames(data)),]
#covariate_clust = cluster(covariates)
clustering = cluster(data,...)
#permuted = permute(genotypes,clustering$clustering)
genotype_template = rownames(data)
names(genotype_template) = genotype_template
to_r = do.call(rbind,mclapply(seq(1:dim(genotypes)[1]),function(x){
genotype_vector=sapply(genotype_template,function(i){
if (class(try(genotypes[x,i],silent=T))!="try-error"){
return(genotypes[x,i])
} else {
return(NA)
}
})
genotype_vector = genotype_vector[!is.na(genotype_vector)]
one_score = score(clustering$clustering,genotype_vector)
o = cbind(one_score$statistic[[1]],one_score$p.value)
colnames(o) = c("matches","pval")
return(o)
}))
to_r[,"pval"] = p.adjust(to_r[,"pval"],method = "BH")
return(to_r)
}
clust_qtl = clustANDscore(data,genotypes_yeast,distance="cosine")
plotManhattan(clust_qtl,markers_yeast, gene,trx_annot=tx_3utr_annotations_yeast_chr01)
clust_qtl
clust_qtl[,"pval"]
min(clust_qtl[,"pval"])
to_r
to_r = do.call(rbind,mclapply(seq(1:dim(genotypes)[1]),function(x){
genotype_vector=sapply(genotype_template,function(i){
if (class(try(genotypes[x,i],silent=T))!="try-error"){
return(genotypes[x,i])
} else {
return(NA)
}
})
genotype_vector = genotype_vector[!is.na(genotype_vector)]
one_score = score(clustering$clustering,genotype_vector)
o = cbind(one_score$statistic[[1]],one_score$p.value)
colnames(o) = c("matches","pval")
return(o)
}))
to_r[,2]
min(to_r[,2])
clust_qtl[,2]
clust_qtl[,2] = to_r[,2]
plotManhattan(clust_qtl,markers_yeast, gene,trx_annot=tx_3utr_annotations_yeast_chr01)
gene = sample(names(tx_3utr_annotations_yeast_chr01),1)
x = subsetByOverlaps(tx3_counts_chr01,tx_3utr_annotations_yeast_chr01[gene])
data = t(granges2matrix(x))
# log transform
data[data==0] = NA
data = log2(data)
data[is.na(data)] = 0
# need to clean up data names
rnames = sapply( sub("X","",sapply( rownames(data), function(i) strsplit(i,"_")[[1]][1] ) ), function(i) {
if (nchar(i)==2){
i = paste("0",i,sep="")
}
i
} )
rownames(data) = rnames
# remove insig peaks
peak_cutoff = find_sigCounts( data )
data_o = data
data[ , colSums(data)<peak_cutoff ] = 0
data = data[rownames(data)%in%colnames(genotypes_yeast),]
clust_qtl = clustANDscore(data,genotypes_yeast,distance="cosine")
plotManhattan(clust_qtl,markers_yeast, gene,trx_annot=tx_3utr_annotations_yeast_chr01)
dim(genotypes_yeast)
.05/12692
genotype_vector
length(genotype_vector)
library(xlsx)
library(ggplot2)
library(plotly)
library(dplyr)
library(reshape2)
source("~/Documents/git/steinmetz-lab/genphen/metabnorm/normfunctions.R")
endo_f = "~/Desktop/tmpdata/endometabolome/endometabolite_14072015.rda"
file.exists(endo_f)
load(endo_f)
ls()
head(endometabolite)
endodata$value.log = log2(endodata$value)
endometabolite$value.log = log2(endodata$value)
min(endometabolite$value)
max(endometabolite$value)
as.numeric(endometabolite$value)
min(as.numeric(endometabolite$value))
processData = function( f1, f2, startRow = 2,... ) {
# f1 is relative time - defined by "cultivation phase"
# eg. Endometabolome_1B_25A_sorted by cultivation phase.xlsx
# f2 contains measurements at absolute time
# eg. Endometabolome_25A_sorted by cultivation time.xlsx
wb1 = loadWorkbook(f1)
wb2 = loadWorkbook(f2)
sheets = intersect(names(getSheets(wb1)),names(getSheets(wb2)))
pb <- txtProgressBar(min = 0, max = length(sheets), style = 3)
o = do.call(rbind,lapply(1:length(sheets),function(i){
setTxtProgressBar(pb, i)
i = sheets[i]
thisf1 = read.xlsx(f1,sheetName=i,startRow=startRow,header=T)
thisf2 = read.xlsx(f2,sheetName=i,startRow=startRow,header=T)
common = intersect(colnames(thisf1),colnames(thisf2))
# keep strains only
common = common[grep("^X",common)]
to_r = do.call(rbind,lapply(common,function(j){
do.call(rbind,lapply(c("relative","absolute"),function(k){
strain = strsplit(j,"_")[[1]][1]
if (nchar(strain)==3) {
strain = gsub("^X","0",strain)
} else {
strain = gsub("^X","",strain)
}
replicate = as.numeric(strsplit(j,"_")[[1]][2])
metabolite = i
if (k=="relative") {
touse = thisf1
} else {
touse = thisf2
}
time = touse[,1]
time_format = k
value = as.numeric(touse[,j])
data.frame(strain,replicate,metabolite,time,time_format,value)
}))
}))
# remove NA
to_r = to_r[!is.na(to_r$value),]
return(to_r)
}))
close(pb)
return(o)
}
calc_deriv = function(df) {
# calc first order finite difference
# order df by time
df = arrange( df,time )
endo_rate = diff( df$endo_quant_log_normalized )
exo_rate = diff( df$exo_quant_log_normalized )
time = sapply( seq( 2, length( df$time ) ), function(i) {
# change to ceil to keep time labeling consistent
ceiling( mean( as.numeric( levels( df$time )[ df$time[ c( i-1,i ) ] ] ) ) )
} )
out = data.frame( metabolite = df$metabolite[1], strain = df$strain[1], parent = df$parent[1], time = time, endo_rate = endo_rate, exo_rate = exo_rate )
return(out)
}
f1 = "~/Desktop/tmpdata/endometabolome/Endometabolome_1B_25A_sorted by cultivation phase.xlsx"
f2 = "~/Desktop/tmpdata/endometabolome/Endometabolome_25A_sorted by cultivation time.xlsx"
endometabolite = processData(f1, f2, startRow = 2)
library(xlsx)
library(rJava)
dif(c(1,2,3,4))
diff(c(1,2,3,4))
?data.frame
?filter
require(stats)
densityplot( ~ height | voice.part, data = singer, layout = c(2, 4),
xlab = "Height (inches)", bw = 5)
library(lattice)
densityplot( ~ height | voice.part, data = singer, layout = c(2, 4),
xlab = "Height (inches)", bw = 5)
windowxy(20)
library(LSD)
windowxy(20)
parmfrow(windowxy(20))
library(clustQTL)
library(clustQTL)
library(clustQTL)
library(clustQTL)
10-2
10^-2
library(clustQTL)
library(clustQTL)
library(clustQTL)
library(clustQTL)
library(clustQTL)
library(clustQTL)
library(clustQTL)
library(clustQTL)
library(clustQTL)
library(clustQTL)
library(clustQTL)
library(clustQTL)
library(clustQTL)
library(clustQTL)
library(clustQTL)
library(qqman)
manhattan(gwasResults,show=F)
library(clustQTL)
library(clustQTL)
library(clustQTL)
library(clustQTL)
library(clustQTL)
library(clustQTL)
#' Format clustQTL results for plotting
