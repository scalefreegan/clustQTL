{
    "contents" : "#' Format clustQTL results for plotting\n#'\n#' This function will format results from running clustQTL for plotting\n#'  as a Manhattan plot with \\code{\\link{plotManhattan}}. Plotting\n#'  is done with plotGradLinear from the ggbio package. This function is\n#'  not usually called directly. It is called by \\code{\\link{plotManhattan}}\n#'\n#' @param qtls A two column matrix with each row containing a pvalue for\n#'  every marker in \\code{mrk}\n#' @param mrk A Granges object containing the location of every genetic marker\n#'  tested by clustQTL\n#' @return GRanges object containing an extra metacolumn \"p\"\n#'  containing the -log10(pvalue) at each marker. This object is suitable\n#'  for plotting with \\code{\\link{plotManhattan}}\n#' @export\n#'\nformat4manhattan = function(qtls, mrk, qqman = TRUE, midpoint = TRUE, restrict = NULL, ...) {\n  if (qqman) {\n    if (midpoint) {\n      # take midpoint instead of entire range\n      bp =  apply(cbind(GenomicRanges::start(GenomicRanges::ranges(mrk)),\n                       GenomicRanges::end(GenomicRanges::ranges(mrk))),1,function(i){round(mean(i))})\n      snp = names(mrk)\n      chr = as.numeric(gsub(\"chr\",\"\",GenomicRanges::seqnames(mrk)))\n      p = qtls[,\"pval\"]\n    } else {\n      # Not implemented\n      #bp =  cbind(GenomicRanges::start(GenomicRanges::ranges(mrk)),\n      #          GenomicRanges::end(GenomicRanges::ranges(mrk)))\n      #snp = rep(names(mrk),length(bp))\n      #chr = rep(GenomicRanges::seqnames(mrk),length(bp))\n      #p = rep(qtls[,\"pval\"],length(bp))\n    }\n    to_r = data.frame(SNP = snp,CHR = chr, BP = bp, P = p)\n    if (!is.null(restrict)) {\n      to_r = to_r %>% filter(.,SNP == restrict)\n    }\n    return(to_r)\n  } else {\n    mrk$p = -log10(qtls[,\"pval\"])\n    return(mrk)\n  }\n}\n\n#' Plot clustQTL results\n#'\n#' The function \\code{\\link{cluster}}\n#'\n#' @param qtls A two column matrix with each row containing a pvalue for\n#'  every marker in \\code{mrk}\n#' @param mrk A Granges object containing the location of every genetic marker\n#'  tested by clustQTL\n#' @param main String used for plot title\n#' @param trx_annot GRanges. \\code{main} show\n#' @param cutoff -log10(pval) signficance cutoff value for QTLs. Used to draw\n#'  horizontal line across plot\n#' @param gene_annot_range\n#' @param cutoff\n#' @return plot\n#' @export\n#'\nplotManhattan = function( qtls, mrk, gene = \"\", trx_annot = NULL,\n                          cutoff = 3, gene_annot_range = c(1000,1000), qqman = T, show = T, ... ) {\n  if (qqman) {\n    if (is.null(rownames(qtls))) {\n      # assume they are in correct order\n      rownames(qtls) = names(mrk)\n    }\n    mrk2 = format4manhattan( qtls, mrk, qqman = T)\n    if (!is.null(trx_annot)) {\n      trx_info = trx_annot[ which(trx_annot$Name == gene), ]\n      trx_granges = GenomicRanges::GRanges(seqnames=GenomicRanges::seqnames(trx_info),\n                                           ranges=IRanges::IRanges(\n                                             GenomicRanges::start(GenomicRanges::ranges(trx_info))-gene_annot_range[1],\n                                             GenomicRanges::end(GenomicRanges::ranges(trx_info))+gene_annot_range[2]))\n      names(trx_granges) = gene\n      gene_snps = mrk2 %>% filter(., CHR == as.numeric(gsub(\"chr\",\"\",GenomicRanges::seqnames(trx_granges))),\n                                  BP >= GenomicRanges::start(GenomicRanges::ranges(trx_granges)),\n                                  BP <= GenomicRanges::end(GenomicRanges::ranges(trx_granges)))\n      to_r = qqman::manhattan(mrk2, highlight = gene_snps$SNP, show = show, ...)\n    } else {\n      to_r = qqman::manhattan(mrk2, show = show, ...)\n    }\n    return(to_r)\n  } else {\n    library(ggplot2)\n    if (is.null(rownames(qtls))) {\n      # assume they are in correct order\n      rownames(qtls) = names(mrk)\n    }\n    mrk2 = format4manhattan( qtls, mrk, qqman = F )\n    if ( (gene != \"\") & ( !is.null(trx_annot) ) ) {\n      # annotate gene\n      trx_info = trx_annot[ which(trx_annot$Name == gene), ]\n      trx_granges = GenomicRanges::GRanges(seqnames=GenomicRanges::seqnames(trx_info),\n                                           ranges=IRanges::IRanges(\n                                             GenomicRanges::start(GenomicRanges::ranges(trx_info))-gene_annot_range[1],\n                                             GenomicRanges::end(GenomicRanges::ranges(trx_info))+gene_annot_range[2]))\n      names(trx_granges) = gene\n      p = ggbio::plotGrandLinear(mrk2, aes(y = p),spaceline = TRUE,cutoff=cutoff,\n                                 ylab=\"-log10(pval)\",\n                                 highlight.gr = trx_granges,...)\n    } else {\n      p = ggbio::plotGrandLinear(mrk2, aes(y = p),spaceline = TRUE,cutoff=cutoff,\n                                 ylab=\"-log10(pval)\",...)\n\n    }\n    p + theme(axis.text.x=element_text(angle=-45, hjust=0))\n  }\n\n}\n\n#' Plot peak profiles\n#'\n#' The function \\code{\\link{cluster}}\n#'\n#' @param qtls A two column matrix with each row containing a pvalue for\n#'  every marker in \\code{mrk}\n#' @return plot\n#' @export\n#'\nplotPeakProfile = function(data, genotypes, marker, peak_sigma = 2, peak_threshold = 1) {\n  library(reshape2)\n  library(Peaks)\n  library.dynam('Peaks', 'Peaks', lib.loc=NULL)\n  library(gtable)\n  library(gridExtra)\n  library(grid)\n  library(dplyr)\n  library(ggplot2)\n  data_mod = t(apply(data,1,function(i){SpectrumSearch(i,sigma=peak_sigma,threshold=peak_threshold)$y}))\n  #data_mod = t(apply(data_mod,1,function(i){i/sum(i)}))\n  colnames(data_mod) = colnames(data)\n  data_long = melt(data, varnames=c(\"y\",\"x\"))\n  data_long$genotype = genotypes[marker,][levels(data_long$y)[data_long$y]]\n  data_long$panel = \"B\"\n  colnames(data_long) = c(\"value\",\"x\",\"y\",\"genotype\",\"panel\")\n  g1 = data_long %>% filter(genotype==1)\n  g2 = data_long %>% filter(genotype==2)\n  s2n = c(seq(1,length(unique(levels(g1$value)[g1$value]))),seq(1,length(unique(levels(g1$value)[g2$value]))))\n  names(s2n) = c(unique(levels(g1$value)[g1$value]),unique(levels(g2$value)[g2$value]))\n  data_long$value = s2n[levels(data_long$value)[data_long$value]]\n  data_long_mod = melt(data_mod, varnames=c(\"y\",\"x\"))\n  data_long_mod$genotype = genotypes[marker,][levels(data_long_mod$y)[data_long_mod$y]]\n  data_long_mod$panel = \"A\"\n  data_long_mod$y = s2n[levels(data_long_mod$y)[data_long_mod$y]]\n  d = rbind(data_long,data_long_mod)\n  # remove 0 values\n  # data_long = data_long[data_long$value!=0,]\n  # data_long[data_long$value==0,]$value = NA\n\n  #panelAylim = max(data_long_mod %>% filter(genotype==1) %>% group_by(genotype,x) %>% summarise(sum=sum(value)) %>% select(sum))\n  p1 <- ggplot() +\n    facet_grid(panel~.,scale=\"free_y\",labeller=function(x,y){return(\"\")}) +\n    stat_summary(data=data_long_mod %>% filter(genotype==1), mapping=aes(y=value,x=x),geom=\"area\",fun.y=sum) +\n    #scale_y_continuous(limits=c(0, panelAylim)) +\n   # geom_line(data=data_long_mod %>% filter(genotype==1), mapping=aes(y=value,x=x),stat=\"mean\") +\n    geom_tile(data = data_long %>% filter(genotype==1), mapping=aes(y = value,x = x,fill = y)) +\n    scale_fill_gradient(low=\"black\", high=\"white\", guide = F, limits=c(0, max(data_long$y))) +\n    labs(x = \"Position\", y = \"Sum Counts\") +\n    ggtitle(\"Genotype 1\")\n  gt1 <- ggplot_gtable(ggplot_build(p1))\n  gt1$heights[[3]] <- unit(.25, \"null\")\n  gt1$grobs[[3]]$children[2]$axis$grobs[[1]]$label = \"\"\n  gt1$grobs[[10]]$hjust = -1.5\n  gt1$grobs[[10]]$vjust = -.25\n\n\n  p2 <- ggplot() +\n    facet_grid(panel~.,scale=\"free\",labeller=function(x,y){return(\"\")}) +\n    stat_summary(data=data_long_mod %>% filter(genotype==2), mapping=aes(y=value,x=x),geom=\"area\",fun.y=sum) +\n    #scale_y_continuous(limits=c(0, panelAylim)) +\n    #geom_line(data=data_long_mod %>% filter(genotype==2), mapping=aes(y=value,x=x)) +\n    geom_tile(data = data_long %>% filter(genotype==2), mapping=aes(y=value,x=x,fill = y)) +\n    scale_fill_gradient(low=\"black\", high=\"white\", limits=c(0, max(data_long$y)),name=\"Counts\") +\n    labs(x = \"Position\", y = \"Sum Counts\") +\n    ggtitle(\"Genotype 2\")\n  gt2 <- ggplot_gtable(ggplot_build(p2))\n  gt2$heights[[3]] <- unit(.25, \"null\")\n  gt2$grobs[[3]]$children[2]$axis$grobs[[1]]$label = \"\"\n  gt2$grobs[[10]]$hjust = -1.5\n  gt2$grobs[[10]]$vjust = -.25\n\n  grid.arrange(gt1,gt2,ncol=2)\n\n}\n\n#' Plot peak profiles\n#'\n#' The function \\code{\\link{cluster}}\n#'\n#' @param qtls A two column matrix with each row containing a pvalue for\n#'  every marker in \\code{mrk}\n#' @return plot\n#' @export\n#'\nwritePeakProfile = function(data, genotypes, marker, peak_sigma = 2, peak_threshold = 1, \n                            f1 = \"/Users/brooks/Sites/JBrowse-1.11.6/data/d1.bw\", f2 = \"/Users/brooks/Sites/JBrowse-1.11.6/data/d2.bw\") {\n  library(reshape2)\n  library(Peaks)\n  library.dynam('Peaks', 'Peaks', lib.loc=NULL)\n  library(gtable)\n  library(gridExtra)\n  library(grid)\n  library(dplyr)\n  library(ggplot2)\n  library(rtracklayer)\n  mrk2geno = genotypes[marker,]\n  #data_mod = as.matrix(mcols(data))\n  #data_mod = t(apply(data,1,function(i){SpectrumSearch(i,sigma=peak_sigma,threshold=peak_threshold)$y}))\n  strain_names = sapply(colnames(mcols(data)),function(i){\n    i = strsplit(i,\"_\")[[1]][1]\n    i = gsub(\"X\",\"\",i)\n    if (nchar(i)==2) {\n      i = paste(\"0\",i,sep=\"\")\n    }\n    if (nchar(i)==3) {\n      return(i)\n    } else {\n      return(NULL)\n    }\n  })\n  gen1 = which(strain_names%in%names(which(mrk2geno==1)))\n  gen2 = which(strain_names%in%names(which(mrk2geno==2)))\n  d1 = rowSums(as.matrix(mcols(data)[,gen1]))\n  d2 = rowSums(as.matrix(mcols(data)[,gen1]))\n  gr1 = data\n  mcols(gr1) = NULL\n  gr1$score = d1\n  gr2 = data\n  mcols(gr2) = d2\n  export.bw(object = gr1, con = f1, compress=T)\n}\n",
    "created" : 1438347698517.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2642550076",
    "id" : "F2DAFB93",
    "lastKnownWriteTime" : 1441383407,
    "path" : "~/Documents/git/steinmetz-lab/clustQTL/R/plot.R",
    "project_path" : "R/plot.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}